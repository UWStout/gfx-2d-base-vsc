/* globals __DEV__ */

// Import bootstrap's contents for webpack (not used below)
// These lines simply ensure that bootstrap is placed in the bundle files
// that are generated by webpack so we don't have to link them separately
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'

// Import jQuery as the usual '$' variable
import $ from 'jquery'

// Import the Program and ArrayBuffer classes from the nano-gl library
// @ts-ignore
import ArrayBuffer from 'nanogl/arraybuffer'
// @ts-ignore
import Program from 'nanogl/program'

// Import functions from matrix_math and utils
import { orthoMatrix } from './matrix_math'
import { getWebGLContext, resizeCanvasToDisplaySize } from './utils'

// @ts-ignore
import Stats from 'stats.js'

// Global variables shared by many of the functions below
// NOTE: These are only accessible in this one file!!
let gl = null // WebGL rendering context
let shader = null // Compiled shader program
let projM = null // The projection matrix (2d, orthographic)

let square = {} // A square shape
let triangle = {} // A triangle shape
let stats = null // FPS monitoring

/**
 * Function to run when page is fully loaded
 */
$(document).ready(() => {
  // Handle a lost webgl context
  let canvas = document.getElementById('c')
  canvas.addEventListener('webglcontextlost', (event) => {
    event.preventDefault()
  }, false)

  // Respond when our webgl context gets restored
  canvas.addEventListener('webglcontextrestored', initializeWebGL, false)

  // Optionally setup FPS counter
  if (__DEV__) {
    stats = new Stats()
    stats.showPanel(0)
    document.body.appendChild(stats.dom)
  }

  // Setup initial webgl context
  initializeWebGL()
})

/**
 * Initialize WebGL for use later in the code. This runs when the document
 * is ready or whenever the WebGL context is restored after being lost.
 */
function initializeWebGL () {
  // Get a WebGL rendering context for the Canvas element
  gl = getWebGLContext($('#c')[0], {
    preserveDrawingBuffer: true,
    antialias: true,
    depth: false
  })

  // Set the clear color to black and opaque
  gl.clearColor(0.0, 0.0, 0.0, 1.0)

  // Create a new shader program and compile and bind our shaders
  shader = new Program(gl, $('#vs').text(), $('#fs').text())
  shader.bind()

  // Build the shapes
  buildShapes()

  // Start / Restart the rendering loop
  requestAnimationFrame(checkRender)
}

/**
 * Build the simple shapes for this scene
 */
function buildShapes () {
  // Make the raw data for the triangle
  triangle._data = new Float32Array([
    -1.5, 1.0, 0.0, // Vertex A
    1.0, 0.0, 0.0, // Color A

    -2.5, -1.0, 0.0, // Vertex B
    0.0, 1.0, 0.0, // Color B

    -0.5, -1.0, 0.0, // Vertex C
    0.0, 0.0, 1.0 // Color C
  ])

  // Make the WebGL ArayBuffer for the triangle (using nanoGL)
  triangle.buffer = new ArrayBuffer(gl, triangle._data, gl.STATIC_DRAW)
  triangle.buffer.attrib('aPosition', 3, gl.FLOAT)
  triangle.buffer.attrib('aColor', 3, gl.FLOAT)

  // Four vertices with position and color all on one line
  square._data = new Float32Array([
    2.5, 1.0, 0.0, 0.5, 0.5, 1.0,
    0.5, 1.0, 0.0, 0.5, 0.5, 1.0,
    2.5, -1.0, 0.0, 0.5, 0.5, 1.0,
    0.5, -1.0, 0.0, 0.5, 0.5, 1.0
  ])

  // Make the WebGL ArayBuffer for the square (using nanoGL)
  square.buffer = new ArrayBuffer(gl, square._data, gl.STATIC_DRAW)
  square.buffer.attrib('aPosition', 3, gl.FLOAT)
  square.buffer.attrib('aColor', 3, gl.FLOAT)
}

/**
 * Check if the window/display size has changed and
 * resize the canvas accordingly.
 */
function resizeCanvas () {
  // Check window size and resize canvas if needed
  if (resizeCanvasToDisplaySize(gl.canvas)) {
    // Canvas was resized so update the viewport
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

    if (__DEV__) {
      // Print the two resolutions to the console to help debugging
      console.info('Canvas: ' + gl.canvas.width + ' x ' + gl.canvas.height)
      console.info('Buffer: ' + gl.drawingBufferWidth + ' x ' + gl.drawingBufferHeight)
    }

    // Update the projeciton matrix to account for the new canvas dimensions
    let ratio = gl.canvas.height / gl.canvas.width
    projM = orthoMatrix(-3 * ratio, 3 * ratio, -3, 3)

    // Indicate that the viewport & canvas were resized
    return true
  }

  // Indicate that the viewport & canvas were NOT resized
  return false
}

/**
 * Check if the canvas needs a resize or the interface has requested a scene update
 * and render the scene if needed. This function is called continuously as part of
 * the rendering loop.
 */
function checkRender (time) {
  if (stats) { stats.begin() }

  // Does canvas need a resize?
  if (resizeCanvas()) {
    // If so, redraw the scene
    renderScene(time)
  }

  if (stats) { stats.end() }

  // Repeat infinitely at a reasonable framerate
  requestAnimationFrame(checkRender)
}

/**
 * Draw all the shapes in the scene
 */
function renderScene (time) {
  // Clear the screen to black (colors only)
  gl.clear(gl.COLOR_BUFFER_BIT)

  // Use the pre-compiled shader
  shader.use()

  renderShapes()
}

/**
 * Draw the two shapes using WebGL
 */
function renderShapes () {
  // Pass this shape's properties into the shader
  shader.uProjection(projM)

  // Bind the position and color attributes for the triangle, then draw
  triangle.buffer.attribPointer(shader)
  triangle.buffer.drawTriangles()

  // Bind the position and color attributes for the square, then draw
  square.buffer.attribPointer(shader)
  square.buffer.drawTriangleStrip()
}
